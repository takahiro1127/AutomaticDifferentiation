# 自動微分 for C++
自動微分をC++で簡単に使うことができる様にしました。
## 自動微分とは
自動微分とは、プログラム上で微分を簡単に正確に高速に行うためのアルゴリズムです。
一般的に広く使われている差分法では微分をした際に誤差が生じてしまうのに対し、自動微分では微分後の関数を求めた後微分値を出力するため、可能な限り微分のごさを少なくすることが可能となっています。
### 自動微分の仕組み  
自動微分は、以下の様な微分の連鎖律を用いることによって実現されています。

<a href="https://www.codecogs.com/eqnedit.php?latex=\left&space;\{f(g(x))\right&space;\}'&space;=&space;f(g(x))g(x)'" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\left&space;\{f(g(x))\right&space;\}'&space;=&space;f(g(x))g(x)'" title="\left \{f(g(x))\right \}' = f(g(x))g(x)'" /></a>

例えばf(g(0))の微分が求めたい場合、g(x)がどの様な式の形であるかを把握していなくても、f(x)の式とg(0), g(0)'の値を知ってさえいればf(g(0))'を求めることができます。
自動微分では、式の演算の一つ一つをこの様に連鎖律に分解する事によって、微分を行っています。
## 自動微分の種類
自動微分にはその実装方法によって二つの種類が存在します。
ボトムアップ型自動微分は直感的に理解しやすく、実装も簡単です。
一変数の微分のみを行う場合は、ボトムアップ型で十分です。
一方でトップダウン式は、やや難解ですが、偏微分を一度に計算することが可能です。
多くの偏微分を一度に計算したい場合はトップダウン型を用いましょう。
### ボトムアップ型自動微分
ボトムアップ型自動微分ではある演算(+, -, expなど)を行う際に、計算に含まれる要素の値と微分の値を使用する事で、その演算自体の微分値を計算していきます。
その様にして計算された演算の値と微分の値はより高次の演算の微分計算において使用されます。
この様に、一つ一つの計算要素からより高次の関数へと微分値を伝搬していく事からボトムアップ型の自動微分と呼ばれています。
#### 具体例
あまりに抽象的な話なので、具体例を示したいと思います。
exp(sin(cos(x)))の微分値を求める事を考えましょう。
1. まず、xの値はx, 微分値は1です。
1. 次に、cos(x)の値はcos(x), 微分値は-sin(x)です。
1. さらに、sin(g(x))の微分は、連鎖律からcos(g(x))g'(x)です。ここで、g(x) = cos(x), g'(x) = -sin(x)である事から、{sin(cos(x))}' =  cos(cos(x)) * -sin(x)
1. 最後にexp(g(x))の微分は、連鎖律からexp(g(x))g(x)'です。ここで、g(x) = sin(cos(x)), g'(x) = cos(cos(x)) * -sin(x)なので、exp(sin(cos(x))) * cos(cos(x)) * -sin(x)
#### 用例
FromBottom.hppをincludeする事によって、ボトムアップ型自動微分を用いる事ができます。
実際に使っているファイルは、test.fromBottom.diff.cppです。
まず、git cloneして、FromBottom.hppを同じディレクトリ内に設置します。

```
#include "FromBottom.hpp"
```
とする事で、FromBottomに定義されているNodeクラスを使用する事ができます。
まずlong double型などで変数を定義してあげます。
次にldの変数を元にNodeを生成します。
```
ld x_val = 0.5;
Node x(x_val);
```
xで微分したい場合は、
```
x.select_as_delta();
```
とする事で、xを微分を行う値として認識します。
xは普通の数値の様に自由に式を組み立てて大丈夫です。
xを元に自由に式を組み立ててみましょう。
```
pow(4 - pow(x, 2), 1.0/3)
```
この式のxでの微分の値をみたい場合は、
```
pow(4 - pow(x, 2), 1.0/3).dval
```
を見る事で確認する事ができます。
また、式の値をみたい場合は、
```
pow(4 - pow(x, 2), 1.0/3).val
```
を見る事で、確認する事ができます。

### トップダウン型自動微分
トップダウン型自動微分では、高次の関数の中で低次の関数が持つ微分値を低次の関数へと伝えていく事で、最終的に最小要素であるxやyが持つ微分値を計算する事ができます。
高次元の関数から低次元の関数に向かって微分の値を伝搬することからトップダウン型の自動微分と呼ばれています。

また、トップダウン型自動微分では偏微分を一括で計算することができるという、ボトムアップ型にはないメリットがあります。

詳しい説明については、図などがあった方がわかりやすいため、こちらを参考にしてください。

[wikipedia](https://ja.wikipedia.org/wiki/%E8%87%AA%E5%8B%95%E5%BE%AE%E5%88%86#:~:text=%E3%83%88%E3%83%83%E3%83%97%E3%83%80%E3%82%A6%E3%83%B3%E5%9E%8B%E8%87%AA%E5%8B%95%E5%BE%AE%E5%88%86%E3%81%A7%E3%81%AF%E3%80%81%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB%E5%BE%AE%E5%88%86%E3%81%95%E3%82%8C%E3%82%8B,%E3%81%84%E3%81%8F%E3%81%93%E3%81%A8%E3%81%AB%E7%9B%B8%E5%BD%93%E3%81%99%E3%82%8B%E3%80%82&text=w%E3%81%AB%E9%96%A2%E3%81%99%E3%82%8B%E5%BE%AE%E5%88%86-,%E3%81%A7%E3%81%82%E3%82%8B%E3%80%82,%E4%B8%8B%EF%BC%89%E3%81%AB%E3%81%9F%E3%81%A9%E3%81%A3%E3%81%A6%E3%81%84%E3%81%8F%E3%80%82)
#### 用例
FromTop.hppをincludeする事によって、ボトムアップ型自動微分を用いる事ができます。
実際に使っているファイルは、test.FromTop.diff.cppです。
まず、git cloneして、FromTop.hppを同じディレクトリ内に設置します。

```
#include "FromTop.hpp"
```
とする事で、FromTopに定義されているNodeクラスを使用する事ができます。
まずlong double型などで変数を定義してあげます。
次にldの変数を元にNodeを生成します。
```
x_val = 5;
y_val = 30;
Node x(x_val);
Node y(y_val);
```
次に、xとyのそれぞれを微分する値として記録します。
後々ここで設定したフラグにアクセスすることで偏微分値を確認することができます。
```
x.setFlagAsVariable(1);
y.setFlagAsVariable(2);
```
この様に自由に式を定義します。
定義した式(f)に対してsetDifferentalを呼び出すことで偏微分値が一括で計算されます。
```
Node f = 9 * pow(x, 2) - 6 * x * y + 4 * pow(y, 2);
f.setDifferental();
```
xの偏微分値を参照したい場合、先ほどxのflagを1で設定していたので、
```
f.flagToDiff[1]
```
といった形で参照することでxの微分値を確認することができます。
また、yも同様に
```
f.flagToDiff[2]
```
とすることで偏微分値を確認することができます。

